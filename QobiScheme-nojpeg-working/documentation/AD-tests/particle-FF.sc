(define (naive-euler w)
 (let* ((charges (list (vector 10.0 (- 10.0 w)) (vector 10.0 0.0)))
	(x-initial (vector 0.0 8.0))
	(xdot-initial (vector 0.75 0.0))
	(delta-t 1e-1)
	(p (lambda (x)
	    (reduce + (map (lambda (c) (/ (distance x c))) charges) 0.0))))
  (letrec ((loop (lambda (x xdot)
		  (let* ((xddot (k*v -1.0 ((gradient-F p) x)))
			 (x-new (v+ x (k*v delta-t xdot))))
		   (if (positive? (vector-ref x-new 1))
		       (loop x-new (v+ xdot (k*v delta-t xddot)))
		       (let* ((delta-t-f (/ (- (vector-ref x 1))
					    (vector-ref xdot 1)))
			      (x-t-f (v+ x (k*v delta-t-f xdot))))
			(sqr (vector-ref x-t-f 0))))))))
   (loop x-initial xdot-initial))))

(define (run)
 (let* ((w0 0.0)
	(w* (multivariate-argmin-F
	     (lambda (w) (naive-euler (vector-ref w 0))) (vector w0))))
  (vector-ref w* 0)))
