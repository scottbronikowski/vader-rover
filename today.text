Random notes:
------------------
(define duplicates (removeq #f (map-indexed (lambda (line i) (if (> (length (removeq #f (map-indexed (lambda (other j) (and (equal? other line) (not (equal? i j)))) symtable))) 0) line #f)) symtable)))

nm -ACgl <library file> to see symbol table and look for name clashes

objdump -p <executable> to see library load order

(load "/home/dpbarret/darpa-collaboration/pose-retraining/olympic-sports-setup.sc")
(annotate-event 8 42)
video GuabYFuZmQw_00967_01667 is actually a snatch, not a clean and jerk
video ivQERlvxQrs_03683_03946 is not a full clean and jerk (starts with the weight off the floor, half-way up to the clean position)
video HMU4DyQB5C4_00803_01368 shows a double clean and jerk (two lifters on the bar)

commands:
from ~/darpa-collaboration/ideas/x86_64-Linux-3.2.0-4-amd64$ darpa-wrap make dsci -j6


Buffers
---------------------------------------
.   today.text           56728  Text		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/today.text
  * *shell*              31093  Shell:run	  ~/vader-rover/
  * *scheme*            489465  Inferior Scheme:
    toollib-rover-cpp.c: 40230  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/toollib-rover-cpp.cpp
    toollib-rover-cpp.h   4874  C++/l		  ~/vader-rover/toollib-rover-cpp.h
    driver-gui.sc         2323  Scheme		  ~/vader-rover/driver-gui.sc
  * *shell*<2>           28642  Shell:run	  ~/darpa-collaboration/ideas/x86_64-Linux-3.2.0-4-amd64/
    toollib-rover.sc      2148  Scheme		  ~/vader-rover/toollib-rover.sc

----old----
    toollib-rover-cpp.c: 35630  C++/l		  ~/vader-rover/toollib-rover-cpp.cpp
. * *shell*<2>           69526  Shell:run	  ~/darpa-collaboration/ideas/x86_64-Linux-3.2.0-4-amd64/
    toollib-rover-cpp.h   4815  C++/l		  ~/vader-rover/toollib-rover-cpp.h
    today.text           46261  Text		  ~/vader-rover/today.text
  * *shell*             327034  Shell:run	  ~/vader-rover/
    deadReckoning.c       6423  C/l		  ~/Downloads/MatrixPilot_4_0/libDCM/deadReckoning.c
    imu-calibration-17-ju: 548  Text		  ~/vader-rover/imu-calibration-17-jun-14.txt
    toollib-gamepad.sc     833  Scheme		  ~/vader-rover/toollib-gamepad.sc
    driver-gui.sc         2158  Scheme		  ~/vader-rover/driver-gui.sc
    toollib-gamepad-c.c  11221  C/l		  ~/vader-rover/toollib-gamepad-c.c
    toollib-rover.sc      2148  Scheme		  ~/vader-rover/toollib-rover.sc
    commander-gui.sc      2321  Scheme		  ~/vader-rover/commander-gui.sc

  * *Open Recent*         3988  recentf-dialog
    toollib-gamepad-c.h   1954  C++/l		  ~/vader-rover/toollib-gamepad-c.h

.   simple-gui.sc         5686  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/simple-gui.sc
    vlad.sc              12997  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/vlad/vlad.sc
    vladlib-c.c          90308  C/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/vlad/vladlib-c.c
    vladlib-cpp.cpp       3000  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/vlad/vladlib-cpp.cpp
    vladlib-sc.sc         3172  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/vlad/vladlib-sc.sc
    toollib-image-proc: 125308  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/ideas/toollib-image-processing.sc
    vladlib-c.h          11671  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/vlad/vladlib-c.h



Old Notes
----------
14 Mar 14
-- converted camera-server.c to cpp in order to use flycap libraries
-- copied flycap headers and so files from vader-ubuntu, but wouldn't work bc version of flycap was too new (GLIBC conflict)-->put these files in ~/vader-rover/OLD/
-- tried copying newer version of glibc (libc-2.15.so and ld-2.15.so) from vader-ubuntu, but this got really hairy really quick.  Then started on a full install of glibc-2.14.tar.gz into ~/vader-rover IOT use newer GLIBC, but abandoned this bc next bullet got working
-- installed flycapture2-2.3.3.18 from ~/darpa-collaboration/bin/build-point-grey.sh in order to avoid conflict with GLIBC version (we have 2.13, flycapture2-2.5+ needs 2.14)
-- created symlinks from ~/vader-rover to lib and include for flycapture
   include -> /home/sbroniko/darpa-collaboration/include/x86_64-Linux-3.2.0-4-amd64/flycapture/
    lib -> /home/sbroniko/darpa-collaboration/lib/x86_64-Linux-3.2.0-4-amd64/
--added 'export LD_LIBRARY_PATH=${HOME}/darpa-collaboration/lib/`architecture-path`/arv:${HOME}/lib/`architecture-path`/:$LD_LIBRARY_PATH:${MATLAB}/bin/glnx86/:${MATLAB}/bin/glnxa64:/usr/local/lib/:~/darpa-collaboration/lib/`architecture-path`/:/usr/local/cuda/lib64/:/usr/share/cuda-toolkit/lib64/' to .bashrc in order to find flycapture libraries at runtime
-- started on building struct and receiver function for raw PGR image...look at using Image() constructor in Image.h where I can pass all paramaters directly.

17 Mar 14
--First test of sending raw images across network successful, images saved via PGR methods into color PPM.  Getting ~1.2-1.3 frames/sec/cam.
--Need to look at using Imlib calls in order to get an Imlib image as a return value.

18 Mar 14
-- Modified camera-server.c to only get image metadata on first image...still need to put in break condition when sender stops sending.

19 Mar 14
-- Finished mod of camera-server.cpp to break out of forked receive process when no image data received--no significant speedup.
----
-- Miniz.c turned out to be slower than sending uncompressed data...looking for different library
-- Now trying 'snappy' from Google

20 Mar 14
-- ***Got framerate to ~8 f/s/c (close to rate at which cameras produce) by 1) changing save location to /aux vice /home, and 2) changing pano cam to 640x480 greyscale
-------
-- working on incorporating snappy compression, bug in ReceiveMetadataCompressed

2 Apr 14
-- Got OpenCV working for JPEG compression.  Can currently send compressed images across network (~15-30 kilobytes per image) and save them on seykhl at ~11.9-12.5 f/s/c as either .jpg or .png (file type doesn't seem to affect speed).

7 Apr 14
--Got QobiScheme to work with jpegs in OpenCV.  Removed references to jpeg* functions in original QobiScheme source files and compiled new QobiScheme-AD.a (./QobiScheme-nojpeg-working/source/x86_64-Linux-3.2.0-4-amd64/QobiScheme-AD.a).  Compiled into dsci and was able to read and write jpeg.

8 Apr 14
--Separated toollib-rover-cpp.cpp declarations/includes/etc into toollib-rover-cpp.h as much as possible.
--Built rover-server-test, rover-server-setup, rover-server-start, rover-server-grab functions into toolib-rover*.
--Have rover-server-setup working (initializes global varaibles used by rover-server-grab)
--First draft of rover-server-start complete.  Can call a single instance of rover-server-grab to listen and receive images on one port.  Put basic thread-safety guards into rover-server-grab.  Need to implement threading in rover-server-start IOT enable both ports to listen simultaneously.
--Also need to develop functions that are the consumers to rover-server-grab's producer.  Envision two functions, one that takes the image and displays it, and one that takes the image and saves it to a video.

9 Apr 14
--Modified rover_server_grab to be callable as a pthread.  Built struct CamGrab_t to hold variables going to rover_server_grab.  From rover_server_start, called rover_server_grab twice (once for each camera) and was able to receive data into separate arrays for each camera.  Now need to work on functions/threads that will use this data (display and save).
---------
--Started work on getting images to display in Scheme GUI.  Need to look at vlad code to see how to use xflush and pthread_barriers.

10 Apr 14
--Got still images into dsci viewer.  Need to work on binding 'test image get' function to a recurring keystroke a la http://www.doctort.org/adam/nerd-notes/x11-fake-keypress-event.html
--Worked out graceful exit and restart for threads so that viewer can be called again in scheme without quitting and restarting dsci.
--Fixed bug in Get_Image_from_ImgArray() that would cause a crash if called before there were images in ImgArray.  Now shows just a gray rectangle.  Could create a rectangle with text saying 'waiting on camera' or something like that.
--Fixed problem in rover-server-grab where I was forking a new process after the server accepted the connection.  Forking didn't allow for shared memory, so I got rid of the fork and did a loop with an exit flag check to replicate the functionality within a single thread.

11 Apr 14
--Have live video in viewer (changed name from 'dsci' to 'rover-viewer').  Image refresh is bound to ESC key, and I send an XEvent after each image received to refresh the window.  Originally had a problem with XEvents only going to the window that the mouse was pointing to, but solved that by designating window for XSendEvent by name.
--Enroute to live video, had several problems with crashes/hangs when the ESC key was held down (fast refresh).  Solved this issue by adding a lock around the integer that keeps track of which image is the most recent in the image receive buffer.
--Next step is to work on camera code on rover to 1) make it run in an infinite loop, 2) be callable from the command line in order to put a button into rover-viewer to start the cameras, and 3) handle a KILL/TERM/?? signal in order to exit gracefully from the infinite loop when signalled from 'stop cameras' button in rover-viewer.

14 Apr 14
--Cleaned up simple-gui.sc a bit.
------
--Added 'Start Cameras' button to simple-gui.sc.  Seems to work as long as only clicked once.  Thinking about putting the 'Start Cameras' function into the initialize/start of rover-viewer so that it only runs once.  Will need to put the signal handler that will shut it down (to be written) into the finalize of rover-viewer.

15 Apr 14
--Cleaned up extraneous printfs in toollib-rover-cpp.cpp.
--Added 'Stop Cameras' button that works with signal handler in run_cameras.cpp on rover using 'pkill run_cameras' sent over ssh.
-----------
--Able to drive rover without line of sight!
--Currently experiencing intermittent problem with USB failing and becoming disabled.  Error message is: 'hub 1-0:1.0: port 2 disabled by hub (EMI?), re-enabling...'  After error, only way I've found to re-enable USB is to reboot rover.  Researching possible solutions.  Will try attaching ferrite cores to USB cables.
--Also noticing a slight list to the left when the rover drives--seeing if adding a shim under the left center wheel will correct this. (first test appeared to make it worse, but will test again)
--When driving around the 3rd floor of EE, the rover sometimes loses connectivity for a few-to-tens-of seconds, presumably when changing APs on PAL.  Need to think of a way to monitor and correct for this (possibly stop when connectivity is lost until regained).  Maybe use wlan0 (built-in wlan) for control and wlan1 (USB wlan) for image streaming...but how would I split up those services to different adapters?

16 Apr 14
--Tested remote driving of rover using 4G modem.  Framerate was reasonable (~8.5 f/s/c), but latency was a problem.  Long delay between when action happened and when image was received, which didn't seem to happen when using wifi.  Also a delay between when command was issued via GUI and when it was executed.  Not sure what can be done to fix this--might the problem go away with better 4G reception (i.e., outdoors)?  Image delay might be helped by reconfiguring image streaming code to use RTP over UDP, instead of the TCP it currently uses.  Don't have any ideas yet on how to improve commands flowing the other direction (currently using ssh to send a command to run an executable that talks to the motors).
--Attempted to test built-in wifi (802.11g only) for remote driving.  Framerate was better than 4G but not as good as USB wifi (got ~10-11 f/s/c from built-in wifi).  Latency didn't seem to be a problem, but the problem of the USB port failing happened much more quickly when USB hub was plugged into main USB host port.  This happened twice in a row, but the third time I was able to get it driving and make a successful loop of EE313.  Also tried with hub plugged into USB OTG port and found the same problem as prevously--get an error message stating (musb_host_rx 1625: Rx interrupt with no errors or packet!) and the capture program freezes until killed.  Pretty sure the USB OTG port is useless.
--Compressed previous backup of SD card in /aux/sbroniko/backup (from 2014-02-03) and initiated new backup prior to changing over to backup gumstix.

17 Apr 14
--Completed and compressed backup of SD card in /aux/sbroniko/backup/sd-backup-2014-04-16.tar.gz
--USB EMI issue seems to have gone away after switching out gumstix/daughterboard and USB cable between gumstix and hub.  Now looking if it's possible to improve how the rover handles moving between wifi APs.

18 Apr 14
--Started overnight test of cameras at 1720 on 17 April and cameras were still running when I came in at 0935 on 18 April.  I believe that we can consider the USB EMI issue solved.
--Received Logitech game controller.  Starting to work on getting it interfaced to seykhl.

21 Apr 14
--DC-to-DC converter on rover damaged while building test kit to measure current from battery--believe it happened when I accidentally reversed the polarity on the battery.  Converter would no longer put out 5V, regardless of the input voltage or the trim pot adjustment.  Spent the rest of the day hooking up the backup converter, this time with proper decoupling capacitors attached via perf-boards.  Seems to work well now.
--Completed creating wiring harness to go in between battery and main power connector to use for measuring current.
--Current readings:
	  5V bus only: 0.50A (steady state after boot complete)
	  5V and 12V on, stationary: initial spike to ~1.37A, then stabilizes at 0.60A
	  Tap bump switches (rover on stand): spikes between 1.6-3.6A, then stabilizes at 0.96A
	  Motors forward_1 (stationary on stand): ~1.38A
	  Motors forward_2 (stationary on stand): ~1.45A
	  Motors forward_3 (stationary on stand): ~1.56A
	  Motors forward_4 (stationary on stand): spikes between 1.8-4.6A, then stabilizes at 1.50A
--Will attempt to take mobile current readings and correct leftward pull while driving tomorrow--need assistance to do that, and by the time I had the power supply fixed this evening, nobody was around.

22 Apr 14
--Found seemingly useful driver/library for using gamepad at https://github.com/elanthis/gamepad.  It builds a shared library and also has a header to call functions that get the controller state.  Have skeleton of toollib-gamepad(.sc, -c.h, -c.c) integrated into dsci.

23 Apr 14
--Got initial functions of toollib-gamepad to work--start and stop cameras.  Discovered problem with sending commands via ssh--button presses send command more than once.  Decided to restructure rover-side code to have one master program (emperor) that listens for commands and then starts threads or calls functions as needed.

24 Apr 14
--Have control message-passing socket working between vader-rover and seykhl.  Vader-rover (emperor.cpp) 'calls home' to seyhkl on port 1999 to establish the socket, then vader listens.  On seyhkl, the port is created in toollib-gamepad.c (gamepad_update())--seyhkl spins waiting for vader-rover to connect, then once connected uses the port to send commands.  Have start and stop cameras working--next up is pan and tilt using right thumb stick.

25 Apr 14
--Got pan and tilt servos for front camera working from right thumbstick of gamepad.  Next up will be the motor commands on the left thumbstick.

28 Apr 14
Goal: Finish mapping driving commands to left thumb stick on game controller.  Implement software fix for leftward pull while driving.
--Have motor commands mapped to positions on left thumbstick in toollib-gamepad-c.c.
--Implemented command checker on seykhl side to prevent sending of duplicate commands to rover.  May need to remove similar checking code on rover side.

29 Apr 14
Goal: Integrate bump switch monitor code into emperor (probably separate thread).  Start work on driver code for shaft encoders and IMU.
--Tracked down slow pan/tilt execution to rover-side motor sending code; fixed.
--Completed and tested implementation of command parsing and sending to motors within emperor.cpp.  Removed extraneous printfs in both toollib-gamepad-c.c on seykhl and emperor.cpp on rover.
-------
--Fixed leftward pull while driving by slowing right motors.
--Rover is now fully controllable from game controller.
--Minor code cleanup in gamepad and rover

30 Apr 14
Goal: Research and prepare order for: extra batteries/chargers, speakers and microphones for bidirectional speech, longer plenum tubing needed for flipped bump switches.  Continue work on shaft encoder and IMU code.
--Built initial data logging infrastructure into dsci (toollib-rover-cpp.cpp, rover_server_log()).  Receives buffer of text sent from rover and saves it in a log file (named with UTC date/time when rover_server_setup() was called).  Have seykhl-side code working implemented and clean startup/shutdown.  Still need to finish code to send data from rover.

1 May 14
Goal: Continue work on shaft encoder and IMU code.
--Logging functional for pan/tilt, motor, and camera commands. Text files saved to ~/vader-rover/logs/.  GMT timestamps come from seykhl, while timestamps in seconds.microseconds come from rover (except for the final 'Logging completed' timestamp--has to come from seykhl b/c shutdown routine uses the socket closing from seykhl side as the notification to rover to stop logging.
--Bump switch monitor functions integrated into emperor.cpp (as separate thread) on rover.  Bump switch messages logged on seykhl.

2 May 14
Goal:Continue work on shaft encoder and IMU code.  Start looking at data logging/recording and time stamping methods.
--Researched and compiled parts order for batteries/chargers, plenum tubing, and speakers/microphone.
--Reversed mounting direction on all bump switches so that now their whiskers will cross at approximately the center line of the rover.  Need longer plenum tubing to make the whiskers reach to the outer edge of the tires.  Checked with machine shop and electronics shop in ECE, and neither had any tubing.
--Started researching methods of converting individual frames into a video using ffmpeg and/or opencv (while preserving timestamp data).  The opencv VideoWriter class looks promising.
--Minor code cleanup on toollib-rover and toollib-gamepad
--Started building functions to send frame capture timestamps (identical to the ones used for commands/bumps) from rover to seykhl on every frame, and then log those timestamps into a separate text file for each camera.  Now each run has a directory named with date and GMT time of starting, then 3 text files (log.txt, front.txt, pano.txt).  File creation and saving on seykhl complete, need to implement the sending of image timestamps on vader-rover and receiving and writing to file on seykhl.

5 May 14
Goal:  Implement sending of image timestamps on rover and receiving and writing to file on seykhl.
--Implemented receive/write of camera start and stop messages in toollib-rover-cpp.cpp (rover_server_grab(), just before and after main capture loop).
--Implemented receive/write of individual timestamps for images--getting odd results on last image timestamp, need to debug.
--Debugged errors in last message--have an exit condition in OpenCV_ReceiveFrame() that allowed that function to return when it received a 0 for image size.

6 May 14
Goal:  Work on saving received images into a video file on seykhl.
--Moved log saving directory and log files from /home/sbroniko/vader-rover/logs to /aux/sbroniko/vader-rover/logs.
----
--Fixed timestamp message length.  Commit prior to testing framerate.
----
--Traced problem with slow framerate to emperor_monitor_bump_switches thread: with thread created and cameras NOT running, CPU usage on rover is ~95% for emperor; without thread and cameras NOT running, CPU usage on rover is <1% for emperor.
--Fixed framerate issue--now getting 11-15 f/s/c (counted using timestamps in log file).
----
--Have video saving working with both cameras using OpenCV VideoWriter.  I have observed that the frame count of the videos as reported by ffmpeg is 1 frame more than the number of frame timestamps I have in my log files.  Need to investigate this to figure out where the error is.

7 May 14
Goal: Continue work on video saving.  Look at sending video to second (commander) workstation--my initial thought is to have the video stream go rover->seykhl (driver)->other ws (commander) in order to keep rover bandwidth usage at current level, but not sure if this will cause perceptible delay.
--Confirmed that framecount from video and number of timestamps are the same by numbering the timestamps in the file.  Apparently the error I though I had yesterday was actually from me miscounting the number of timestamps in the file.  
--Spent most of the day helping Dan with annotations.

8 May 14
Goal:  Continue work on video to second workstation.  Start work on drivers for shaft encoders and IMU.
--Spent all day working on video annotations.

9 May 14
Goal:  Continue work on shaft encoders and IMU.
--Spent all day working on video annotations.

12 May 14
Goal: Work on video annotations.
--Annotations all day.

13 May 14
Goal: Finish video annotations. Work on setting up commander viewer on second workstation--first try video stream going rover->seykhl (driver)->other ws (commander) in order to keep bandwidth usage at current level.  See if this setup causes perceptible delay.
--Annotations all day.

14 May 14
Goal: Finish commander viewer.  Work on setup and mounting of speakers and microphone on rover.  See machine shop if additional hardware needed.
--Annotations all day.

15 May 14
Goal: Start work on drivers for shaft encoders and IMU.
--Started work on running commander viewer on separate workstation.  Building tools into toollib-rover(.sc, -cpp.cpp, -cpp.h) with 'cdr_' prefix.  Will create separate commander-gui.sc to run the tools from.  Also ported simple-gui.sc to driver-gui.sc and cleaned up/fixed buttons.

16 May 14
Goal: Continue work on shaft encoders and IMU.
--Commander viewer is functional.  Tested in tandem with driver viewer (both side-by-side on seykhl via ssh into chino, and locally on the alykkyys desktop) and there does not appear to be any noticeable delay--we tested by putting a stopwatch in front of the camera and comparing the times in both windows, and the times matched.
--A current limitation of the commander viewer is that it needs to be running prior to starting the cameras on the rover, otherwise it will not connect when seykhl (the driver gui) looks for it.  I have implemented a button on the driver's GUI that shows whether or not the commander's display is connected (updates on camera start).  I might want to try to modify this button to allow for an attempt at connecting if disconnected, but not sure if this is necessary.
--Commander viewer originally had a problem with the 'Quit' button.  If operator hit 'Quit' button in commander viewer, the image stream would stop but the window would remain open until the cameras are stopped.  I changed that behavior with an int variable in C (read into a boolean in Scheme) that determines whether or not the commander viewer is active.  If the viewer is active, the quit button does nothing.  If the viewer is not active, the quit button closes the viewer window--in fact, the driver needs to completely exit his Scheme process before the commander's viewer can be closed.  This prevents the commander from accidentally or prematurely closing his window while the driver is still driving.

19 May 14
Goal: Start work on shaft encoder driver.
--Started by looking for existing code to read rotary encoders.  Found a couple of ARM-specific projects (running in user-space) that seem to do an adequate job of reading encoder position and counting ticks, but they use too much CPU (~50%) to work on the rover.  I tested these while running the cameras and observed noticeably slower frame rate and occasional freezes.  I am now researching ways to do interrupt handling (i.e., tick counting) in kernel-space to try to achieve lower CPU usage.  Another option (which I haven't researched yet) is to use one or two separate microcontrollers (with pulse accumulators) to count ticks and then have the Gumstix poll the microcontrollers at a reasonable interval for data.


20 May 14
Goal: Continue work on shaft encoder driver.
--All work done on rover.

21 May 14
Goal: Complete work on shaft encoder driver.  Start work on IMU driver.
--All work done on rover.

22 May 14
Goal: Continue work on IMU driver.
--All work done on rover.

23 May 14
Goal: Complete work on IMU driver.
--Ordered Teensy 3.1 microcontroller board (72 MHz ARM Cortex-M4, 256k flash, 64k RAM, 34 digital IO pins--all interruptable, USB interface to PC).  Not sure if it will be capable of running both encoders from one Teensy, so I ordered enough to put two Teensys on the rover, with spares.  There seems to be a fairly active dev community for the Teensy, with an already-existing Encoder library built for quadrature encoders (code appears to be all in C).  These boards were surprisingly cheap, <$20/board.
--Installed longer whiskers on bump switches.  Rear switches seem to be working fine.  Front switch whiskers sag down in front of the ultrasonic sensor, which will render that sensor useless.  I need to figure out a way to keep the whiskers clear of the sensor.  The first thing I tried was to mount an old whisker sticking out the front of the rover for the new whiskers to rest on (above the sensor's path), but that doesn't seem to work to well--the new whiskers don't move as freely as they need to.  One thought is to use a smoother material (metal?) for the whisker rest to reduce friction.  Another thought is to move the ultrasonic sensor to another location--possibly mounted on top of the pan/tilt camera.  That might prove more useful, giving a distance to whatever the camera is looking at rather than a distance from the front of the rover.

27 May 14
Goal:  Read up on Teensy development and ensure development environment is set up and ready for when board arrives.  Visit machine shop to start work on mounting hardware for speakers and mic.
--Discovered that all kernel module compilation work done on Friday needs to be undone--it destroyed my previous kernel modules and made the Gumstix unable to boot with the correct drivers.

28 May 14
Goal:  Start work on IMU code.
--Got basic rotary_encoder.ko module compiled on rover.
--Took rover down to machine shop for mic and speaker mounting.  Mic is mounted on rear left corner of rover, next to battery and DC-DC converter.  Speakers are mounted underneath, between front and middle wheels, angled outwards towards side of rover (angle is changeable due to hinges on back of speakers).
--Started reading up on Teensy (Arduino) development environment.

29 May 14
Goal:  Continue work on IMU code.
--Got Arduino/Teensyduino IDE installed on Ubuntu laptop and seykhl.  Arduino IDE does not require installation, it just runs via an executable script extracted with the download, and Teensyduino just installs helper files in the extracted directory.  Created an alias in my .bashrc to call that script.  Just need udev rules added by root to access boards via USB.

30 May 14
Goal:  Complete and test IMU code.
--All work done on rover.

2 Jun 14
Goal:  Continue work on IMU. Decide on what data I want to get from the IMU, and in what format.  
--Teensy boards on hand.
--Working on calibrating IMU and modifying AHRS code for IMU to report only info that is relevant to what I'm doing.


3 Jun 14
Goal:  Continue work on IMU.  Integrate IMU data request/reply and sending to seykhl over network into emperor code on rover.
--IMU calibration on rover (mag: output.txt, others in today.text on rover).


4 Jun 14
Goal:  Complete work on IMU.
--Revised IMU magnetometer calibration on rover (output2.txt).  Determined that IMU needs to be mounted higher off the rover's deck in order to minimize magnetic interference.

5 Jun 14
Goal:  Start work on Teensy as wheel encoder controller.
--New calibration in output3.txt


6 Jun 14
Goal:  Continue work on Teensy.
--Spent about an hour and a half trying to figure out compass offset without success.  Tried in several different locations (on floor in office, on floor in hallway, further down the hallway) and got useless results--the same magnetic heading, as measured by my lensatic compass, gave different headings from the IMU when measured multiple times.  I think recalibration might be a fix, but not sure of what location to use for recalibration.  I'm starting to think that might just be too much EM interference here inside the building.  I'm going to give this issue a rest for a while and instead work on the data flow from IMU->rover->seykhl->log.

9 Jun 14
Goal: Continue work on IMU data flow. 


10 Jun 14
Goal:  Work on IMU calibration (probably outdoors)


11 Jun 14
Goal:  Finish work on IMU data flow. 


12 Jun 14
Goal:  Work on GPS data flow (should be a quick modification from IMU data flow). 


13 Jun 14
Goal:  Start work on encoder->Teensy interface. 

16 Jun 14
Goal: Research availability of a time of day clock on the IMU and see if it can be used to timestamp data.  Start working on integrating accelerometer data to get velocity and position.
--Discovered upon reading about the instruction set that the IMU has that there doesn't appear to be any kind of time of day clock available on the IMU.  However, there is a millis() function that returns the number of milliseconds since the current program started running (overflows after ~50 days, so should be suitable for my purposes).  I could use this to implement a timer on the IMU that sends data to the Gumstix at a set interval (100 ms if we want 10 updates/sec), which would remove the need for the Gumstix to poll the IMU for data.  Timestamping of the data could then be done upon its arrival at the Gumstix, before transmission to seykhl.
--Read more into the DCM algorithm implemented in the razor-9dof-ahrs code I'm using as my base.  The comments in the code seem to indicate that the DCM algorithm does some amount of integration, so I'm trying to understand that more in an effort to do my own integration on the IMU.  DCM (Direction Cosine Matrix) seems to be very similar to the rotation matrices used in ECE569.   


17 Jun 14
Goal:  Do outdoor calibration of IMU (best chance of a day without rain).  Continue working on integration on IMU.
--Redid calibration of IMU outdoors (picnic table in front of south wing of EE building).  File saved as imu-calibration-17-jun-14.txt.
--Broke one front bump switch during calibration--need to replace the switch with a spare.


18 Jun 14
Goal:  Continue working on integration on IMU.
--Started an in-depth reading of the paper by Premerlani that the razor-9dof-ahrs code is based on, with the goal of understanding their algorithm and exactly how it is implemented in the code in order to modify it in order to use the IMU for positioning.  Also started reading the papers by Mahony that the Premerlani paper is based on.
--Also worked on MA511 readings and homework.

19 Jun 14
Goal:  Finish IMU integration--IMU should be able to output raw/calibrated accel/gyro data, integrated velocity, integrated position, and heading.
--MA511 homework and Premerlani/Mahony paper reading.

20 Jun 14
Goal:  Work on GPS data flow to Gumstix.
--Finished MA511 homework.  Next week I'll try to get the homework done in smaller chunks.
--Continued reading the Premerlani and Mahony papers.  Reading these carefully in order to get a good understanding of the algorithm before I go mucking with the IMU code that implements it.  
--Also read some more about Kalman filtering in general and how it can apply to robot navigation/positioning specifically.  Spent some time thinking about the fact that once I have working encoders, I will be able to measure my wheel velocity (and thereby the robot velocity) directly.  I know this won't be of much help with what I'm trying to do with the IMU right now, but it provides another input (along with IMU and GPS) to the Gumstix, where I'll implement some sort of filter (Kalman or ???) to synthesize my sensor data into position.  Since what I'm trying to do on the IMU is integrate linear acceleration to get linear velocity (albeit with accumulating error), will this directly measured velocity from the encoders enable me to correct my error before integrating the velocity into position?  Or with measured wheel velocity, can I just skip integrating the IMU linear acceleration and instead use the velocity from the encoders to go to position?  I would think that more sensor data would be better than less, but I'm not sure.  I'll have to keep thinking about this, especially as I continue reading and picking apart the IMU code.

23 Jun 14
Goal: Read Premerlani and Mahony papers
--Completed reading Premerlani paper.  Started on first Mahony paper.
--General algorithm idea is this:  In the DCM algorithm, they get orientation by integrating gyro signals and using accelerometer signals to correct for drift/error.  I want to do the same thing in reverse: integrate accel signals to get to velocity, and use gyros (or magnetometers) to correct drift/error.  Not sure what I can use to correct for error accumulation when going from velocity to position.

24 Jun 14
Goal: Finish reading Premerlani and Mahony papers
--Continued reading Mahony.
--Replaced broken bump switch on rover in preparation for IMU data gathering runs.


25 Jun 14
Goal: Start modifications to IMU code to get at least part of the way from acceleration to position.
--Started building infrastructure to send raw IMU data (3 sensors x 3 axes) through gumstix to a separate log file on seykhl for offline algorithm development.
--IMU currently outputting sensor values (from Razor_AHRS firmware) that don't seem to have any grounding in the physical world--numbers just seem to be values in the range of the ADC. I guess this was more efficient when doing the DCM algorithm, but I think it makes more sense for me to use values that mean something (i.e., accelerometer in m/s^2, gyro in deg/sec, magnetometer in degrees of declination/inclination).  Need to get the necessary info from the individual sensors' data sheets in order to convert these numbers to physical values.
--Also started reading up on methods of numerical integration.  Discovered Verlet integration, which appears to have been developed as a way to numerically integrate Newton's equations of motion (i.e., from acceleration back to displacement--exactly what I'm trying to do!).  It seems to be computationally feasible, even on the IMU's microcontroller (4 multiplies and 2 adds per iteration).  However, I'm not sure about the error performance, and there will be additional computations needed if my time step is not fixed.  Also read a little bit about the Runge-Kutta method, which may be more accurate (but at the cost of more computations).

26 Jun 14
Goal: Continue work on IMU code.
--Continued building infrastructure to log IMU data into separate log file.  Have the file created on seykhl and a socket listening on a separate port.  
--Ran into a couple of bugs and had to spend some time fixing them before I could test interaction between seykhl and the rover for the new log file: 1) front camera was not working at all and the startup was hanging on it--troubleshot the software for a while, only to figure out that unplugging the camera and plugging it back in fixed the problem, and 2) my regular (command) log files were exploding to MB size with a ton (100,000s) of extra newlines at the end of the file--tracked it down to a logic mistake in the rover_server_log() function in toollib-rover-cpp.cpp
--After I fixed those problems, I started testing the logging of IMU data.  I haven't been able to get IMU data across yet.  In toollib-rover-cpp on seykhl, currently trying to have new log socket monitored in rover_server_log thread, and I think this might be the problem--it doesn't seem to be accepting the connection from the rover until I shut down the viewer.  Will troubleshoot this more tomorrow.

27 Jun 14
Goal: Continue work on IMU code.
--Completed MA511 HW #2 (approx. 1 hour per day this week)
--Troubleshot error with the new log socket on seykhl to the fact that both the old log socket and the new IMU log socket were somehow getting the same file descriptor number, which was causing an error.  I was able to overcome this by putting some additional logic conditions around when these file descriptors got closed, ensuring that the attempts to open them were sequential rather than simultaneous.  However, once I got that fixed I started getting bad file descriptor errors when I shut down the emperor code on the rover.  I believe the issue is with the loop conditions around my select/recv loop.  Need to find and use a function that checks if a given integer is a vaild file descriptor.

30 Jun 14
Goal: Finish debugging IMU logging and research conversion factors for IMU data to physical data.
--Implemented a function in toollib-rover-cpp that checks for a file descriptor for validity using fcntl (is_valid_fd()).  Using it in loop conditions in rover_server_log() and it seems to fix the bad file descriptor errors I was having on Friday.
---
--Successfully have IMU logging data split out to separate file.  Everything seems to be functioning properly after the split.
--Noticed some extra newlines in the regular data log file.  After some debugging, figured out that there were some receives on seykhl that weren't receiving a full buffer before returning, so the receives following those were coming up empty.  Put a little check after the receive to make sure that the buffer didn't start with a '\0' or a '\n', and that seemed to fix the problem.

1 Jul 14
Goal:  Implement IMU logging of physical quantities, collect data for algorithm development, and start algorithm development.
--Got standalone IMU program working on rover.  Still only getting about 37 Hz updates (vice 50 Hz).  First draft at implementing timestamp from IMU instead of from Gumstix.

2 Jul 14
Goal: Continue working on algorithm.
--Got IMU timestamp working more efficiently.  After IMU timestamp, could not get Gumstix to pull data from IMU faster than 25 Hz.  Changed the design to have the IMU push data as fast as it computes it, and have the Gumstix loop on a listener.  This got updates at as close to 50 Hz as I think we can get (intervals between IMU data -- measured by IMU clock -- were all either 20 or 21 ms, for a run of ~3000 samples).

3 Jul 14
Goal:  Complete algorithm development, implement on IMU, and test.
--See rover log

7 Jul 14
Goal: Collect IMU data for algorithm development.  Look at what IMU output is when rover is at rest and think about how it will affect velocity/position calculations.
--Collected IMU data for rover at rest on desk (1 file, ~2300 samples), rover at rest on floor (1 file, ~5100 samples), rover driving just forward between the two marked points on the floor (2 files, ~3700 samples total, although there were some slight turns/pivots during these runs), and the rover driving back and forth between the two points (1 file, ~5100 samples, with minimal to no turning/pivoting).  Next need to analyze this data--probably plotting each acceleration axis as a function of time (for moving samples), or plotting histograms of acceleration values (for still samples)

8 Jul 14
Goal:  Start IMU algorithm development.
--Noticed that accelerometer output was not normalized, due to differently scaled x, y, z axes used in DCM algorithm.  Implemented a normalization of the axes just before multiplying by g0.  This seemed to improve accuracy of IMU output--prior to normalization, IMU output (x,y,z in cm/s^2) was on the order of ([-5.54,9.23], [-16.81,-5.60], [928.36, 947.04]) for the rover at rest, which was far off the ideal of (0, 0, 980.665).  After normalization, output was ([-17.35,-1.91], [-17.61, -1.93], [980.46, 980.65]).  The post-normalization data was taken with the rover on the desk, so the negative tilts on the x and y axes may be due to the fact that the rover doesn't sit perfectly level on the desk.  I will need to recheck the level of the IMU with the rover sitting on the floor.  I will also need to retake the data I took yesterday, since the non-normalized data is probably not useful.


9 Jul 14
Goal:  Continue work on IMU algorithm.
--Teensy mounted, connected, able to count ticks of wheel using example program.

10 Jul 14
Goal:  Complete algorithm development, implement on IMU, and test.
--12V wall power supply in use.
--Did some runs over measured distance to determine tick count per cm for each wheel.
--Studied for MA511 midterm.
--Started backup of rover SD card at 1707 using command 'dd if=/dev/sdg | gzip > ./sd-backup-2014-07-10.gz' in /aux/sbroniko/backup/20140710.  To unzip, use 'gzip -dc /path/to/image.gz | dd of=/dev/sdx' (directions found at http://raspberrypi.stackexchange.com/questions/311/how-do-i-backup-my-raspberry-pi).  Monitoring dd using 'watch -n60 'kill -USR1 $(pgrep ^dd)''

11 Jul 14
Goal:  Refine IMU algorithm as needed.  Start setting up wheel encoder to Teensy interface.
--Backup of SD card completed overnight.
--Shortened the wifi and front camera USB cables.
--Had some sort of power surge when powering up the robot and had several components rendered inoperable (no physical damage, but will not power on or respond).  The destroyed components are: DC-DC converter, USB hub, Teensy, GPS, Wifi adapter.  I have ordered replacements for the Wifi (should arrive tomorrow), as well as the GPS and USB hub (should arrive by Tuesday).  I had a spare Teensy on hand, and it has already been replaced.  I also have the parts on hand to replace the DC-DC converter--I have started that repair and will come in tomorrow to finish it.  With any luck, I'll also have the new Wifi adapter by that time and can install that tomorrow as well.
--I will be able to continue working on Teensy programming on Monday and Tuesday while awaiting parts, since I have to use my laptop to upload the code to the Teensy anyways. 


14 Jul 14
Goal: Finish replacement of USB hub and recheck functionality.  Repeat experiment from last Thursday to see if the change in weight/distribution changed the ticks/cm count.  Start working on Teensy program to report cm traveled.
--Got USB hub completely replaced (mounted, Gumstix remounted and wires rerouted, USB cable spliced, hub power cable built and wired into 5V bus on rover).  All systems appear to function normally.  

15 Jul 14
Goal:  Replace GPS receiver (exact replacement, no change to weight/distribution). Continue working on odometry program (Teensy->Gumstix->seykhl log file).
--Got GPS receiver installed and plugged into permanent port (w/ shortened cable).  It appears to function normally--can read GPGGA, GPGSA, GPRMC, GPGSV NMEA sentences at 4800 baud via screen.


16 Jul 14
Goal:  Complete odometry program.  Write similar program to get data from GPS and send it back to seykhl.
--Receiving raw NMEA sentences from rover into imu-log.txt.  First draft did not have both GPS and IMU data in the log file (only one or the other) because the code on the seykhl side was not set up to accept multiple connections to the port that logs to that file.  Need to modify rover_server_log in toollib-rover-cpp.cpp in order to allow 3 different connections (IMU, GPS, encoders) to the log_imu_sockfd port (which in turn is how we write to imu-log.txt)


17 Jul 14
Goal:  Complete GPS program.  Start collecting consolidated position sensor data over a known/measured route.
--Finished modifications to toollib-rover-cpp.cpp to allow simultaneous logging to the same file.  Logging works--GPS messages are interspersed among IMU messages.  Added code to also enable encoder logging when the Teensy code is ready.
--Noticed a slowdown in camera frame rate to ~6-7fps/cam (normally 11-12fps/cam).  Tried rebooting and it didn't seem to fix the problem.  Need to figure out what changes to the code caused the slowdown--suspect it is something in toollib-rover-cpp.cpp
--Fixed camera frame rate slowdown by reworking the logic in the inner loop of rover_server_log() in toollib-rover-cpp.cpp.  Changed the loop to only check the log_threads_should_die flag instead of checking is_valid_fd() for each fd every iteration.  Framerate back to normal.
--Changed frame rate parameter in call to cv::VideoWriter (in rover_server_setup(), toollib-rover-cpp.cpp) to 10.5 from 12.0 to better reflect the actual frame rate that I'm getting from the cameras (taken from the camera timestamp log files, dividing number of frames by (last frame time - first frame time)).  This only affects the saved AVI files, not the real-time display in the viewer.
--Repeated the tick count over known distance drive experiment from 10 Jul to see if the change in hardware (different USB hub, different cable arrangement) had an effect on the ticks/cm measurements.  The new tick counts are LEFT = 328.288 ticks/cm and RIGHT = 323.709 ticks/cm.  Measurements were taken from 5 runs, varying between 15.66' and 68.38'.  R^2 values on both linear regressions were > 0.999998, so I'm confident that the linear fit is good and using ticks to measure cm traveled will give accurate numbers.

18 Jul 14
Goal:  Complete data collection and start development on trace algorithm.
--Worked on MA511 HW4 and readings.
--Started on Teensy code to read encoders and output each wheel's cm traveled every 20ms.  Have the code ~50% done, and rsync'ing it back to seykhl to be git'ed with the code there.  Will be in tomorrow (and probably Sunday as well) to work on it, since my family is on vacation in Kansas for the next week to 10 days.  By the end of the weekend I plan to have collected consolidated data files (IMU, GPS, encoder) of at least one or two runs of the rover driving loops around the EE313 complex.

19 Jul 14
--Completed Teensy code for odometers.  Teensy reliably outputs a cm traveled reading for each encoded wheel every 20ms.

20 Jul 14
--Changed binary mode of Teensy output to send floats (cm measurements) first so that encoders_data_read() in run-encoders.cpp can more closely match razor_data_read() in razor-imu.cpp.
--Made modifications to toollib-rover-cpp.cpp to have 3rd sensor (encoders via Teensy) connected and logging to imu-log.txt.  Seems to be working.
--Looked at camera logs and confirmed that with all 3 sensors running, the framerate is still ~10 fps/camera (same as before I wrote the sensor monitoring programs).
--Looked at a log file from a run while on the stand and saw that once all three sensors got going, the output was generally as expected--alternating ENC and IMU messages (both at 50 Hz), with GPS messages interspersed at 1 Hz.  
--Noticed a few cases where there was a series of two or three ENC messages followed by two or three IMU messages. On some of these the out-of-order messages would have been in-order if the Gumstix timestamps had been written in order (i.e., a line had a timestamp that was earlier--by ~.001s--than the line above it).  This leads me to believe that the out-of-order problem lies within the Gumstix and its context switching of the processes that do the logging.  I don't think this will be a problem, since the IMU and encoders each have their own internal timestamps that we can use (although those timestamps are not synchronized)
--Also noticed that as the sensors come online, in about the 1st second of operation, there are a bunch of encoder messages in a row, all before the IMU comes online.  I wonder if there is a way to suppress these messages...or if it's even necessary to do so, since it should be easy to ignore them when processing the imu-log file.  Need to think about this a little more.  Once I figure this out, I'll be ready to do a few drives around the office in order to collect data to use with Dan's Kalman filter code.

21 Jul 14
Goal: Finish final tweaks/debugging of sensor logging.  May have to slow IMU and encoder updates down to 40 Hz (instead of 50 Hz) because I saw in the log that the time interval between some IMU updates was 21 ms, while the encoders were always at 20 ms, which causes these two sensors to get out of sync with each other.  I think slowing the requested interval down to 25 ms between updates is the easiest fix.  Also look at sensor startup in log--is it necessary to sync the start of each sensor's messages?  Once these are fixed, take some log data of rover driving in different patterns around the office.
--Changing the update interval on the IMU to 25 ms (vice 20 ms) did not seem to work.  With the interval set at 20 ms, the measured interval (using IMU clock) was roughly 50% at 20 ms, and 50% at 21 ms.  When I changed it to 25 ms, I measured roughly 50% at 25 ms, 40% at 26 ms, and 10% at 27 ms.  I tried changing then interval to 50 ms, I measured ~75% at 51 ms and ~25% AT 52 ms (i.e., NONE at exactly 50 ms).  Setting the interval at 40 ms also didn't work.  Next going to try to use the function micros() to try to get higher resolution timing.
--Got timing on IMU working using micros() timer.
--Modified rover_server_log() in toollib-rover-cpp.cpp to:
   1) close the fds from each sensor (and command log) when the sender performs and orderly shutdown (recv retval == 0)
   2) only log the start message ('X logging started') from each sensor until all 3 sensors have sent that message.


22 Jul 14
Goal:  Read up on Kalman filters (I have a couple of book chapters handy) and start looking at Dan's Kalman and NMEA (GPS) parser code.
--Mods to rover_server_log() appear to work as intended.  Still have a few extra messages from the 3rd sensor to start appearing in rapid succession (< requested interval, according to Gumstix timestamp) after connection (seems like a serial buffer clearing out).  Implemented small 'null' loop on rover in run-imu and run-encoders that reads data without sending for ~200 ms before starting to send.
--In long (>70 minute) run to test rollover logic in IMU code, noticed several garbled messages (excess newlines, cutoff lines, and lines that don't start with the timestamp as they should).  Fixed it by creating a function that handles the recv and fprint uniformly with error checks (same as I had done for just the command log file)
--Noticed problem that when I would run (viewer '()) multiple times without closing and restarting dsci, there would be network errors that certain sockets wouldn't connect--usually the IMU, but sometimes one of the cameras.  The error messages were that bind() failed due to address already in use.  Tried to correct this by adjusting when sockets were closed, but had no luck. 
--Was able to get multiple runs of (viewer '()) working by resetting all the new connection sockets to -1 at the start of rover_server_log().  This forced all to reconnect.  I think the problem was that the fd integer used by the previous call to connect was getting reused by another socket, which bypassed the call to reconnect since that fd integer was valid.
--Next effort is to try to combine separate executables on rover for gps, imu, encoders into a single program that sends a consolidated sensor message to the log.  In addition to avoiding the socket problems, this would also solve the problem of synchronizing the messages from the imu and encoders.

23 Jul 14
Goal:  Start adapting Dan's code to work with my data.
--Drove rover on one loop (counterclockwise) of EE313 complex and one run out EE313G, left down to water fountain, and back into EE313G to give Dan some live log files with IMU and encoder data to use with Kalman filter.

--Built run-sensors.{cpp,h}, which will run the encoders and IMU in sync with each other.  Basically it's a merge of run-encoders and run-imu.
--Modified rover_server_log() in toollib-rover-cpp.cpp to use only two connections to imu-log.txt (since encoders and IMU are now together)



24 Jul 14
Goal:  Continue adapting code.

--Also look at adding Dan's mNMEAParser code to rover_server_log() or on rover

25 Jul 14
Goal:  Produce first (x, y, orientation) trace from log data and Kalman filter and compare against path driven.


***********************TODO*******************************

***any value in trying to sync clocks on IMU and Teensy to Gumstix system clock?

*****in rover_server_log, do I want to close the FDs when the sender shuts down?????

**IMU dev/testing
  -have IMU output raw (calibrated?) sensor data
    --scrap DCM section (how to bypass??)
  -output raw sensor data through Gumstix to seykhl with timestamps (separate text file??)
    --collect ~10 minutes worth of data of driving around a known path (rectangle around EE313)
  -develop algorithm on seykhl to take raw sensor data and convert to a trace (format something like timestamp:x:y:heading:??)
  -have some small throw-away code on seykhl (scheme or matlab) that reads in trace data and plots it to compare against known path

**HOW can I take acceleration data from IMU and integrate it to get velocity and position???

**I can measure wheel velocity directly using the encoders--how does this help?

--Time of day clock on IMU--sync it to Gumstix clock--use it to timestamp data from IMU

***LOOK AT CALLING TOOLLIB-GAMEPAD FUNCTIONS FROM SCHEME FOR BUTTONS (START/STOP CAMERAS, MOTORS, ETC...*****

--LOOK AT INTERFACE TO TEENSY BOARD.  Specifically how to poll it for data.  Sending a request to it over serial interface might be too slow-->can I use a GPIO pin on the Gumstix to send an interrupt to the Teensy that will cause it to send its counts/directions over serial to Gumstix and then reset counters?   
--SHUTDOWN switch/button for gumstix to ensure clean shutdown before power off


--When/where to log????
--Will changing front cam to black & white give sharper picture and/or lower CPU usage?


Critical tasks
--------------
-front camera video-->COMPLETE
-fisheye camera video-->COMPLETE
-game controller to control wheels-->COMPLETE
  --pan-tilt commands-->COMPLETE
  --wheel commands-->COMPLETE
-bump sensors-->COMPLETE
-crossing bump sensors-->COMPLETE, may need adjustment
-shaft encoders-->mounted and connected, need to do software interface 
  --user-space interface on Gumstix too slow/CPU hog
  --could try to implement kernel-space interrupt-driven driver, but not sure if it will consume too much CPU; compilation environment for kernel module rotary_encoder (provided with Linux kernel) set up, but need to figure out how to configure code to monitor the GPIO lines I'm using and have the module keep track of ticks and direction and report them to user-space code on demand
  --separate USB microcontroller board on hand (Teensy 3.1), dev environment for Teensy setup complete on rover and ubuntu laptop, will start work on this once IMU complete
-IMU-->mounted and connected, working on software interface
  --remounted adjacent to camera to try and combat magnetic interference; recalibrated outdoors and magnetometer seems to be working more consistently
  --have data (from Razor_AHRS firmware) read into gumstix and sent over network to seykhl and logged in log file
  --working on getting raw sensor data (possibly converted into m/s^2 for accelerometers???)  sent back to seykhl and logged in order to work on integration of acceleration to position offline
-GPS-->mounted and connected, can read raw NMEA data through a 4800 bps serial port, need to finish software interface

Non-critical tasks
------------------
-ultrasonic sensor-->need to remount, reconnect, and do software interface
-video feed to commander-->first draft COMPLETE, may need future enhancement
-bidirectional speech between driver and rover-->hardware mounted and connected, need to do software
  --speakers and microphone mounted on rover, audio connections connected to Gumstix, USB socket broken out from the 5V DC-DC converter to power speakers.
-bidirectional speech between commander and driver-->not started, hardware on hand
-touchscreen-->mounted and able to connect, need to work on connection to OS
-4G-->COMPLETE


Old buffers
----------------
    today.text            9617  Text		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/today.text
    toollib-rover-cpp.c: 18616  C++/l		  ~/darpa-collaboration/ideas/toollib-rover-cpp.cpp
  * *scheme*           9167396  Inferior Scheme:
    toollib-image-proc: 125308  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/ideas/toollib-image-processing.sc
    toollib-rover-cpp.h   4407  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/toollib-rover-cpp.h
 %  *Man fcntl*          34094  Man
    simple-gui.sc         5609  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/simple-gui.sc
    toollib-rover.sc       864  Scheme		  ~/vader-rover/toollib-rover.sc
    toollib-image-proce: 97076  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/imitate/tool/toollib-image-processing.sc
    arm-servoing-gui.s: 225677  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/imitate/tool/arm-servoing-gui.sc
    vladlib-sc.sc         3172  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/vlad/vladlib-sc.sc
    vlad.sc              12997  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/vlad/vlad.sc
    vladlib-cpp.cpp       3000  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/vlad/vladlib-cpp.cpp
    vladlib-c.h          11671  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/vlad/vladlib-c.h
    vladlib-c.c          90308  C/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/vlad/vladlib-c.c
    idealib-c.c          39638  C/l		  ~/darpa-collaboration/ideas/idealib-c.c
    georgelib-c.c       159141  C/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/source/georgelib-c.c
    george.sc            22480  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/source/george.sc
    georgelib-sc.sc      95501  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/source/georgelib-sc.sc
    point-grey.c         13455  C/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/point-grey/point-grey.c
    point-grey.h          3067  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/point-grey/point-grey.h
    toollib-camera.sc    20563  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/imitate/tool/toollib-camera.sc
    toollib-c.c          21830  C/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/imitate/tool/toollib-c.c
    toollib-farneback-c.: 7956  C/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/ideas/toollib-farneback-c.c
 %  Imlib2.h             25394  C++/l		  /usr/include/Imlib2.h
    point-grey-cpp.cpp     780  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/point-grey/point-grey-cpp.cpp
    camera-server.cpp    10455  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/camera-server.cpp
    makefile|ideas       14766  GNUmakefile	  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/ideas/makefile
    ptgrey-guilib-c.h     4030  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/imitate/ptgrey-gui/source/ptgrey-guilib-c.h
    env-vars.sh            608  Shell-script[bas  ~/darpa-collaboration/bin/env-vars.sh
    darpa-wrap             371  Shell-script[bas  ~/darpa-collaboration/bin/darpa-wrap
    Makefile|vader-rover   966  GNUmakefile	  ~/vader-rover/Makefile
    .bashrc               4944  Shell-script[bas  ~/.bashrc
    ptgrey-guilib-c.c    17181  C/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/imitate/ptgrey-gui/source/ptgrey-guilib-c.c
    select-restart.c       876  C/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/select-restart.c
    rover-server.c        2657  C/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/rover-server.c
    open-files-7-march.t: 2091  Text		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/open-files-7-march.txt
    makefile|source      11614  GNUmakefile	  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/source/makefile
    camera-server-daemon   813  Shell-script[bas  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/camera-server-daemon
    idealib-cpp.cpp       2862  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/ideas/idealib-cpp.cpp
 %  toollib-image-proc: 124889  Scheme		  /amd/upplysingaoflun/root/aux/home/dpbarret/darpa-collaboration/ideas/toollib-image-processing.sc
 %  toollib-hog-hmm-c.c  16888  C/l		  /amd/upplysingaoflun/root/aux/home/dpbarret/darpa-collaboration/ideas/toollib-hog-hmm-c.c
 %  toollib-hog-hmm.sc  196853  Scheme		  /amd/upplysingaoflun/root/aux/home/dpbarret/darpa-collaboration/ideas/toollib-hog-hmm.sc
    georgelib-c.h        28129  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/source/georgelib-c.h
    georgelib-cpp.cpp    14657  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/george/source/georgelib-cpp.cpp
    toollib-hack-track-: 25620  C/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/ideas/toollib-hack-track-c.c
    toollib-hack-track-c: 9555  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/ideas/toollib-hack-track-c.h
    toollib-hack-track.: 14154  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/ideas/toollib-hack-track.sc
    toollib-hack-track-d: 4820  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/darpa-collaboration/ideas/toollib-hack-track-drawable.sc
    SaveImageToAviEx.cpp  8140  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/pgr-src/SaveImageToAviEx/SaveImageToAviEx.cpp
    Makefile|CustomImageE: 700  GNUmakefile	  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/CustomImageEx/Makefile
    CustomImageEx.cpp    31206  C++/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/CustomImageEx/CustomImageEx.cpp
    build-point-grey-2.5.: 729  Shell-script[bas  ~/darpa-collaboration/bin/build-point-grey-2.5.sh
    ptgrey-gui.sc         7541  Scheme		  /amd/upplysingaoflun/root/aux/home/sbroniko/imitate/ptgrey-gui/source/ptgrey-gui.sc
    open_files_4feb.txt   1886  Text		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/open_files_4feb.txt
    server.c              1583  C/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/server.c
    server2.c             2225  C/l		  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/server2.c
    server                 380  Shell-script[bas  /amd/upplysingaoflun/root/aux/home/sbroniko/vader-rover/server
